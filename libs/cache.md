# 缓存

2026-01-05⭐
@author Jiawei Mao
***

## 简介

在高性能 Java 应用中，缓存是王道。在多线程环境中，实现方式对可扩展性和响应性能影响很大。除了简单的 HashMap, Guava 的 `Cache` 和 Caffeine 都提供了缓存功能。性能对比：

- `ConcurrentHashMap`
- Guava `Cache`
- Caffeine Cache

**大型数据集（ 1,000,000）**

- 低并发 `ConcurrentHashMap` 最佳：10 线程以下
- Caffeine Cache 的扩展性最强，当线程超过 16，其性能超过 `ConcurrentHashMap`
- Guava Cache 很稳健，但最慢

**小型数据集（100,000）**

- 所有实现在小型数据集中都更快
- 低并发依然是 `ConcurrentHashMap` 最快
- 高并发 Caffeine Cache 最佳（>=16）

**并发缓存选择**

- 低到中等并发，推荐 `ConcurrentHashMap`
- Caffeine Cache 高性能、功能丰富：如果需要**智能缓存**，**高负载**下稳定，则为首选

## 缓存和池化

**缓存**

将经常访问的数据或计算结果存储在内存中，以减少反复计算或从原始源获取。

缓存的主要目的是提供更快的数据访问，从而提升性能，避免重复生成这些数据的消耗。

缓存主要管理存储在其中对象的声明周期，定期更新或刷新数据。与 pool 不同，缓存不确定它保存对象的类型，只是充当临时存储机制。

**池化**

池化管理一组资源，如连接或实例，每次新请求时重复使用，而不是创建或销毁。一个常见实例是数据库连接池，连接保持活跃并在多个请求之间共享，以避免每次建立新连接的开销。

与专注于数据存储和检索优化的缓存不同，pool 侧重于资源管理和优化。pool 处理资源的创建和销毁，决定同时存在多少实例，以防止资源耗尽和不必要的开销。

**池化与缓存的联系**

缓存与池化都是为了提供系统性能和资源利用率，通过将资源或数据存储在集中的数据 结构中，在需要时进行分配和访问。但是，池化侧重于资源的管理和分配，缓存侧重于数据的存储和访问。

**池化与缓存的区别**

池化与缓存在应用场景和目的上有所不同。池化技术主要用于资源的管理和分配，如内存、文件句柄、网络连接等，以提高性能性能和资源利用率；缓存则侧重于数据的存储和检索，提高数据访问速度，降低数据方位开销。

## 参考

- https://medium.com/@abhaybansal.1988/cache-comparison-benchmarking-hashmap-guava-and-caffeine-under-heavy-load-8345cba9e318
- https://github.com/ben-manes/caffeine
